<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AI ê°€ìœ„ë°”ìœ„ë³´ ê²Œì„</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="container">
    <div class="card">
      <div class="header">
        <h1>âœŒï¸âœŠâœ‹ AI ê°€ìœ„ë°”ìœ„ë³´</h1>
        <p>ì¹´ë©”ë¼ë¥¼ ì¼œê³  ê°€ìœ„, ë°”ìœ„, ë³´ ì¤‘ í•˜ë‚˜ë¥¼ ë³´ì—¬ì£¼ì„¸ìš”.<br>AI ëª¨ë¸ì´ ë‹¹ì‹ ì˜ ì†ì„ ì¸ì‹í•˜ì—¬ ìŠ¹ë¶€ë¥¼ ê²¨ë£¹ë‹ˆë‹¤!</p>
      </div>

      <div class="webcam-wrapper">
        <div id="webcam-container">
          <div class="placeholder-text" id="placeholder">ì¹´ë©”ë¼ ë¡œë”© ëŒ€ê¸°ì¤‘...</div>
        </div>
      </div>

      <div class="status-area">
        <div id="countdown" class="countdown"></div>
        <div id="result" class="result-message"></div>
        <div id="match-detail" class="match-info"></div>
      </div>

      <div class="btn-group">
        <button id="start-cam-btn" class="btn" onclick="init()">ğŸ“¸ ì¹´ë©”ë¼ ì¼œê¸°</button>
        <button id="play-btn" class="btn" onclick="playGame()" disabled>ğŸ® ê°€ìœ„ë°”ìœ„ë³´!</button>
      </div>

      <div class="score-board">
        <div class="score-item">
          <div class="score-label">Player</div>
          <div id="score-player" class="score-val">0</div>
        </div>
        <div class="score-item">
          <div class="score-label">Draw</div>
          <div id="score-draw" class="score-val">0</div>
        </div>
        <div class="score-item">
          <div class="score-label">Computer</div>
          <div id="score-com" class="score-val">0</div>
        </div>
      </div>
      
    </div>

    <div class="card contact-card">
      <div class="header">
        <h2>ğŸ“© ë¹„ì¦ˆë‹ˆìŠ¤ ë¬¸ì˜</h2>
        <p>ê´‘ê³  ì œíœ´ ë° í”¼ë“œë°±ì€ ì•„ë˜ í¼ì„ í†µí•´ ë‚¨ê²¨ì£¼ì„¸ìš”.</p>
      </div>
      <form action="https://formspree.io/f/mjggbojl" method="POST" class="contact-form">
        <div class="form-group">
          <label for="name">ì„±í•¨</label>
          <input type="text" id="name" name="name" placeholder="í™ê¸¸ë™" required>
        </div>
        <div class="form-group">
          <label for="email">ì´ë©”ì¼ ì£¼ì†Œ</label>
          <input type="email" id="email" name="_replyto" placeholder="example@domain.com" required>
        </div>
        <div class="form-group">
          <label for="message">ë¬¸ì˜ ë‚´ìš©</label>
          <textarea id="message" name="message" rows="4" placeholder="ë¬¸ì˜ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”." required></textarea>
        </div>
        <button type="submit" class="btn">ë³´ë‚´ê¸°</button>
      </form>
    </div>

    <div class="card contact-card">
      <div class="header">
        <h2>ğŸ’¬ ëŒ“ê¸€</h2>
      </div>
      <div id="disqus_thread"></div>
      <script>
          /**
          *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
          *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
          /*
          var disqus_config = function () {
          this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
          this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
          };
          */
          (function() { // DON'T EDIT BELOW THIS LINE
          var d = document, s = d.createElement('script');
          s.src = 'https://sunnyssam.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
          })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </div>

  <script id="dsq-count-scr" src="//sunnyssam.disqus.com/count.js" async></script>

  <!-- Teachable Machine Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>

  <script>
    // -------------------------
    // CONFIG & STATE
    // -------------------------
    const URL = "https://teachablemachine.withgoogle.com/models/9vxjsUgVK/";
    let model, webcam, labelContainer, maxPredictions;
    let isModelLoaded = false;
    
    // Scores
    let wins = 0;
    let loses = 0;
    let draws = 0;

    // DOM Elements
    const btnStartCam = document.getElementById("start-cam-btn");
    const btnPlay = document.getElementById("play-btn");
    const elCountdown = document.getElementById("countdown");
    const elResult = document.getElementById("result");
    const elMatch = document.getElementById("match-detail");
    const elScorePlayer = document.getElementById("score-player");
    const elScoreCom = document.getElementById("score-com");
    const elScoreDraw = document.getElementById("score-draw");
    const elPlaceholder = document.getElementById("placeholder");

    // -------------------------
    // INIT WEBCAM & MODEL
    // -------------------------
    async function init() {
      if (isModelLoaded) return;
      
      btnStartCam.innerText = "â³ ë¡œë”©ì¤‘...";
      btnStartCam.disabled = true;

      const modelURL = URL + "model.json";
      const metadataURL = URL + "metadata.json";

      try {
        model = await tmImage.load(modelURL, metadataURL);
        maxPredictions = model.getTotalClasses();

        // Setup Webcam
        const flip = true; 
        webcam = new tmImage.Webcam(300, 300, flip); 
        await webcam.setup(); 
        await webcam.play();
        window.requestAnimationFrame(loop);

        // Append to DOM
        const wcContainer = document.getElementById("webcam-container");
        elPlaceholder.style.display = "none";
        wcContainer.appendChild(webcam.canvas);

        isModelLoaded = true;
        btnStartCam.style.display = "none"; // Hide start button
        btnPlay.disabled = false; // Enable Play button
        
        console.log("Model Loaded. Classes:", model.getClassLabels());

      } catch (e) {
        console.error(e);
        alert("ì¹´ë©”ë¼ ì ‘ê·¼ ê¶Œí•œì´ í•„ìš”í•˜ê±°ë‚˜ ëª¨ë¸ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        btnStartCam.innerText = "ğŸ“¸ ì¹´ë©”ë¼ ì¼œê¸°";
        btnStartCam.disabled = false;
      }
    }

    async function loop() {
      webcam.update(); 
      // We don't predict every frame for performance, 
      // and only predict when game triggers 'capture'.
      // But to keep webcam smooth, we update it.
      window.requestAnimationFrame(loop);
    }

    // -------------------------
    // GAME LOGIC
    // -------------------------
    async function playGame() {
      if (!isModelLoaded) return;
      
      // 1. Reset UI
      btnPlay.disabled = true;
      elResult.innerText = "";
      elResult.className = "result-message";
      elMatch.innerHTML = "";
      
      // 2. Countdown
      let count = 3;
      elCountdown.innerText = count;
      
      const timer = setInterval(async () => {
        count--;
        if (count > 0) {
          elCountdown.innerText = count;
        } else {
          // 3. Capture & Predict
          clearInterval(timer);
          elCountdown.innerText = "Shoot!";
          
          await handlePrediction();
          
          // Reset button after short delay
          setTimeout(() => {
             elCountdown.innerText = "";
             btnPlay.disabled = false;
          }, 1500);
        }
      }, 800);
    }

    async function handlePrediction() {
      // Predict User's Move
      const prediction = await model.predict(webcam.canvas);
      
      // Find class with highest probability
      let maxProb = 0;
      let userMove = "";
      
      for (let i = 0; i < maxPredictions; i++) {
        if (prediction[i].probability > maxProb) {
          maxProb = prediction[i].probability;
          userMove = prediction[i].className;
        }
      }

      // Computer's Move (Random)
      // We assume standard RSP if we can't map model labels perfectly,
      // but let's try to map model labels to 0:Rock, 1:Paper, 2:Scissors logic if possible.
      // Since we don't know EXACT labels of user model, we will use text matching.
      
      // Standardize user move to: 'rock', 'paper', 'scissors'
      const userStandard = standardizeMove(userMove);
      
      // Random Com Move
      const moves = ['rock', 'paper', 'scissors'];
      const comMove = moves[Math.floor(Math.random() * 3)];
      
      // Display
      const userDisplay = getDisplayEmoji(userStandard) + " " + userMove;
      const comDisplay = getDisplayEmoji(comMove) + " Computer";
      
      elMatch.innerHTML = `<span>${userDisplay}</span> <span class="vs-badge">VS</span> <span>${comDisplay}</span>`;

      // Judge
      if (userStandard === "unknown") {
        elResult.innerText = "â“ ì¸ì‹ ì‹¤íŒ¨ (ë‹¤ì‹œ í•´ë³´ì„¸ìš”)";
        return;
      }

      const result = getResult(userStandard, comMove);
      
      if (result === "win") {
        elResult.innerText = "ğŸ‰ ì´ê²¼ìŠµë‹ˆë‹¤!";
        elResult.classList.add("win");
        wins++;
        elScorePlayer.innerText = wins;
      } else if (result === "lose") {
        elResult.innerText = "ğŸ˜­ ì¡ŒìŠµë‹ˆë‹¤...";
        elResult.classList.add("lose");
        loses++;
        elScoreCom.innerText = loses;
      } else {
        elResult.innerText = "ğŸ¤ ë¹„ê²¼ìŠµë‹ˆë‹¤";
        elResult.classList.add("draw");
        draws++;
        elScoreDraw.innerText = draws;
      }
    }

    // -------------------------
    // HELPER FUNCTIONS
    // -------------------------
    function standardizeMove(label) {
      // Convert User's Teachable Machine Label to 'rock' | 'paper' | 'scissors'
      // Need to be flexible with English/Korean
      const lower = label.toLowerCase();
      
      if (lower.includes("ê°€ìœ„") || lower.includes("scissors") || lower.includes("sciss")) return "scissors";
      if (lower.includes("ë°”ìœ„") || lower.includes("rock") || lower.includes("stone")) return "rock";
      if (lower.includes("ë³´") || lower.includes("paper") || lower.includes("bo")) return "paper";
      
      // Fallback: If labels are just "Class 1", "Class 2"... we might need user mapping.
      // For now, let's assume default TM order if text fails: 0:Rock, 1:Paper, 2:Scissors? 
      // Actually TM order depends on user. 
      // Let's try to map based on common index if strings fail. 
      // (Risk: If user trained Paper first, this will be wrong. But better than nothing)
      // Uncomment below if text matching fails often.
      /*
      const labels = model.getClassLabels();
      const index = labels.indexOf(label);
      if (index === 0) return "rock";
      if (index === 1) return "paper";
      if (index === 2) return "scissors";
      */
      
      return "unknown";
    }

    function getDisplayEmoji(move) {
      if (move === "rock") return "âœŠ";
      if (move === "paper") return "âœ‹";
      if (move === "scissors") return "âœŒï¸";
      return "â“";
    }

    function getResult(u, c) {
      if (u === c) return "draw";
      if (u === "rock") return (c === "scissors") ? "win" : "lose";
      if (u === "paper") return (c === "rock") ? "win" : "lose";
      if (u === "scissors") return (c === "paper") ? "win" : "lose";
      return "draw";
    }

  </script>
</body>
</html>